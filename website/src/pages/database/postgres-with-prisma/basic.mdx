# Basic

We'll start with implementing [the basic GraphQL schema](/get-started#basic). This will help you get a basic understanding of what GraphQL is and how its Schema Definition Language (SDL) looks like.

## Prerequisites

- [Postgres with Prisma introduction and setup](introduction)

## Preparation

We of course want to create a type-safe GraphQL schema and resolvers. In order to achieve this type-safety, we'll leverage the magic of [GraphQL Code Generator](https://the-guild.dev/graphql/codegen).

Let's start by installing the code generator and the necessary plugins:

```sh npm2yarn
npm i @graphql-codegen/cli @graphql-codegen/typescript @graphql-codegen/typescript-operations @graphql-codegen/typescript-resolvers
```

Now we will configure codegen to generate the TypeScript resolvers to `schema/basic.graphql.d.ts` using the [basic GraphQL schema](/get-started#basic) as the source:

```ts filename="examples/database/mongodb/codegen.basic.ts"
import { CodegenConfig } from '@graphql-codegen/cli';
import { schemaPath } from '@schema/basic';

const config: CodegenConfig = {
  config: {
    // Types are easier to handle compared to enums.
    enumsAsTypes: true,
  },
  generates: {
    'schema/basic.graphql.d.ts': {
      schema: schemaPath,
      plugins: ['typescript', 'typescript-operations', 'typescript-resolvers'],
    },
  },
};

export default config;
```

And then finally run the generation to get the TypeScript definitions:

```sh npm2yarn
npm exec graphql-codegen -c codegen.basic.ts
```

## Schema

### Prisma

Let's start by defining the basic Prisma schema for the database in `prisma/basic.prisma`.

```prisma filename="examples/database/postgres-with-prisma/prisma/basic.prisma"
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

enum TaskStatus {
  TODO
  IN_PROGRESS
  DONE
}

model Task {
  id          String     @id @default(uuid())
  status      TaskStatus
  title       String
  description String?
}
```

After creating the Prisma schema, lets migrate it to the database.

```sh npm2yarn
npm exec prisma migrate dev --schema prisma/basic.prisma --name init
```

Finally, we'll want to generate the type-safe Prisma client following the Prisma schema.

```sh npm2yarn
npm exec prisma generate --schema prisma/basic.prisma
```

### GraphQL

Cool, we now have prepared the type definitions, implemented the Prisma schema and can finally implement the schema.

We'll use two helpful tools that make this process much more ergonomic. First one is [executable schema builder from GraphQL Tools](https://the-guild.dev/graphql/tools/docs/generate-schema) that we'll use for the schema implementation, and the second one is the [file loader also from GraphQL Tools](https://the-guild.dev/graphql/tools/docs/schema-loading#load-typedefsdocumentnode-and-resolvers-from-files) that will help us load the actual GraphQL schema file.

```sh npm2yarn
npm i @graphql-tools/schema @graphql-tools/load-files
```

```ts filename="examples/database/postgres-with-prisma/schema/basic.ts"
import { makeExecutableSchema } from '@graphql-tools/schema';
import { loadFilesSync } from '@graphql-tools/load-files';
import { Resolvers } from './basic.graphql';
import { schemaPath } from '@schema/basic';
import { prisma } from '../prisma';

const resolvers: Resolvers = {
  Query: {
    task(_parent, args) {
      return prisma.task.findUniqueOrThrow({
        where: {
          id: String(args.id),
        },
      });
    },
    filterTasks(_parent, args) {
      if (!args.searchText) {
        return prisma.task.findMany();
      }
      return prisma.task.findMany({
        where: {
          OR: [
            {
              title: {
                contains: args.searchText,
              },
            },
            {
              description: {
                contains: args.searchText,
              },
            },
          ],
        },
      });
    },
  },
  Mutation: {
    async createTask(_parent, { input }) {
      return await prisma.task.create({
        data: {
          title: input.title,
          description: input.description,
          status: input.status || ('TODO' as const),
        },
      });
    },
  },
};

// Schema builder function. The result is a ready-to-use executable GraphQL schema.
export async function buildSchema() {
  return makeExecutableSchema({
    typeDefs: loadFilesSync(schemaPath),
    resolvers: [resolvers],
  });
}
```
